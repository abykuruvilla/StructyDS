package com.kaby.ds.recursion;

import com.kaby.ds.helper.Pair;
import com.kaby.ds.helper.ResultPair;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ParentheticalPossibilities {

    /**
     * Write a function, parentheticalPossibilities, that takes in a string as an argument. The
     * function should return an array containing all of the strings that could be generated by expanding
     * all parentheses of the string into its possibilities.
     * <p>
     * For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.
     *
     * @param args
     */
    public static void main(String[] args) {

        // == test_00: ==

        List<String> result0 = parentheticalPossibilities("x(mn)yz"); // -> 
        List<String> expected0 = Arrays.asList("xmyz", "xnyz");
        ResultPair<List<String>, List<String>> resultPair0 = new ResultPair<>("Parenthetical possibilities ", expected0, result0);
        resultPair0.printResultPair();

        // == test_01: ==

        List<String> result1 = parentheticalPossibilities("(qr)ab(stu)c"); // ->
        List<String> expected1 = Arrays.asList("qabsc", "qabtc", "qabuc", "rabsc", "rabtc", "rabuc");
        ResultPair<List<String>, List<String>> resultPair1 = new ResultPair<>("Parenthetical possibilities ", expected1, result1);
        resultPair1.printResultPair();

        // == test_02: ==

        List<String> result2 = parentheticalPossibilities("taco"); // ->
        List<String> expected2 = Arrays.asList("taco");
        ResultPair<List<String>, List<String>> resultPair2 = new ResultPair<>("Parenthetical possibilities ", expected2, result2);
        resultPair2.printResultPair();

        // == test_03: ==

        List<String> result3 = parentheticalPossibilities(""); // ->
        List<String> expected3 = Arrays.asList("");
        ResultPair<List<String>, List<String>> resultPair3 = new ResultPair<>("Parenthetical possibilities ", expected3, result3);
        resultPair3.printResultPair();

        // == test_04: ==

        List<String> result4 = parentheticalPossibilities("(etc)(blvd)(cat)"); // ->
        List<String> expected4 = Arrays.asList(
                "ebc", "eba", "ebt", "elc", "ela",
                "elt", "evc", "eva", "evt", "edc",
                "eda", "edt", "tbc", "tba", "tbt",
                "tlc", "tla", "tlt", "tvc", "tva",
                "tvt", "tdc", "tda", "tdt", "cbc",
                "cba", "cbt", "clc", "cla", "clt",
                "cvc", "cva", "cvt", "cdc", "cda",
                "cdt"
        );
        ResultPair<List<String>, List<String>> resultPair4 = new ResultPair<>("Parenthetical possibilities ", expected4, result4);
        resultPair4.printResultPair();


    }

    //    x(mn)yz will be broken into sub problems
    //
    //              x
    //             / \
    //            m   n
    //            |   |
    //            y   y
    //            |   |
    //            z   z
    private static List<String> parentheticalPossibilities(String str) {
        // For an empty string return a list with
        if (str.isEmpty()) {
            return Arrays.asList("");
        }

        // choices are the possibilities within the parenthesis
        // remaining is the part after removing any choices
        Pair<String, String> choicesAndRem = getChoicesHelper(str);
        String choices = choicesAndRem.getValA();   // in case of (mn)yz will be mn
        String remaining = choicesAndRem.getValB(); // in case of (mn)yz will be yz

        List<String> suffixes = parentheticalPossibilities(remaining); // will be called on string yz

        List<String> possibilities = new ArrayList<>();
        for (char choice : choices.toCharArray()) {
            for (String suffix : suffixes) {
                possibilities.add(choice + suffix); // choices will be m and n added to suffix yz giving myz and nyz
            }
        }

        return possibilities;
    }

    private static Pair<String, String> getChoicesHelper(String str) {

        // if the str starts with a parenthesis '(' it is the start of a group like in (mn)yz
        if (str.startsWith("(")) {
            // end of a group is identified by ')'
            int endIndexOfGroup = str.indexOf(")");

            String choices = str.substring(1, endIndexOfGroup);  // in case of (mn)yz will be mn
            String remainingStr = str.substring(endIndexOfGroup + 1); // in case of (mn)yz will be yz

            return new Pair<>(choices, remainingStr);
        } else {
            // Else it is a section with say yz, in which case we take the y and return it
            String choices = String.valueOf(str.charAt(0)); // in case of yz will be y
            String remainingStr = str.substring(1); // in case of yz will be z

            return new Pair<>(choices, remainingStr);
        }
    }
}
